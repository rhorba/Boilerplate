# User Group Management - Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: use executing-plans skill to implement this plan task-by-task.

**Goal:** Implement user group management with group-based role assignment, migrating from direct user-to-role to user-to-group-to-role architecture.

**Architecture:** Clean migration approach creating personal groups for existing users to preserve access. Backend uses Spring Boot 3.4 with Flyway migrations, JPA entities, MapStruct DTOs, and REST controllers. Frontend uses Angular 18 with TanStack Query for state management and Tailwind CSS for styling.

**Tech Stack:** Spring Boot 3.4 (Java 21), Angular 18, Flyway, MapStruct, Tailwind CSS, PostgreSQL/H2.

---

## Execution Progress

**Last Updated:** 2026-01-31 18:51 (COMPLETED)

**Overall Progress:** 18/18 tasks completed (100%) ✅

**Completed Batches:**
- ✅ Batch 1: Tasks 1-5 (Database Schema & Migrations) - COMPLETE
- ✅ Batch 2: Tasks 6-9 (Domain Layer - Entities & Repositories) - COMPLETE
- ✅ Batch 3: Tasks 10-15 (Application Layer - DTOs, Mappers, Services) - COMPLETE
- ✅ Batch 4: Tasks 16-18 (Presentation Layer - Controller & Tests) - COMPLETE
- ✅ Batch 5: Tasks 19-21 (Frontend Core - Models & Services) - COMPLETE
- ✅ Batch 6: Tasks 22-24 (Frontend Components - UI) - COMPLETE
- ✅ Batch 7: Tasks 25-27 (Routes, Navigation & Final Integration) - COMPLETE

**Current Status:** ✅ IMPLEMENTATION COMPLETE - Ready for End-to-End Testing

**Implementation Summary:** See IMPLEMENTATION_SUMMARY.md for full details

**Completed Tasks:**
1. ✅ Task 1.1: Created V12__create_groups_table.sql
2. ✅ Task 1.2: Created V13__create_user_groups_table.sql
3. ✅ Task 1.3: Created V14__create_group_roles_table.sql
4. ✅ Task 1.4: Created V15__migrate_user_roles_to_groups.sql
5. ✅ Task 1.5: Tested migrations locally - BUILD SUCCESS
6. ✅ Task 2.1: Created Group.java entity - compiles successfully
7. ✅ Task 2.2: Updated User.java (changed roles to groups) + Fixed UserPrincipal, AuthService, UserService
8. ✅ Task 2.3: Created GroupRepository with JOIN FETCH queries
9. ✅ Task 2.4: Updated UserRepository (groups-based queries) - BUILD SUCCESS
10. ✅ Task 3.1: Created GroupResponse DTO
11. ✅ Task 3.2: Created GroupRequest DTO with JSR-303 validation
12. ✅ Task 3.3: Created GroupAssignUsersRequest DTO
13. ✅ Task 3.4: Created GroupMapper (MapStruct) - generates implementation
14. ✅ Task 3.5: Created GroupHasUsersException + updated GlobalExceptionHandler
15. ✅ Task 3.6: Created GroupService with full CRUD logic - BUILD SUCCESS

**Critical Fixes Applied:**
- Updated UserPrincipal to load roles from groups (flattened from all group memberships)
- Updated AuthService registration to create personal groups instead of direct role assignment
- Updated UserService create/update methods to work with personal groups
- Fixed batch delete admin check to use groups path

**Additional Completed Tasks (Batches 6-7):**
16. ✅ Task 4.1: Created GroupController with 7 REST endpoints - VERIFIED
17. ✅ Task 4.2: Updated UserResponse DTO (added groups field) - VERIFIED
18. ✅ Task 4.3: Created GroupServiceTest (7/7 tests passing) - VERIFIED
19. ✅ Task 5.1: Created TypeScript interfaces (group.model.ts) - VERIFIED
20. ✅ Task 5.2: Created GroupService (Angular) - VERIFIED
21. ✅ Task 5.3: Updated UserResponse model (added groups) - VERIFIED
22. ✅ Task 6.1: Created GroupListComponent (table view) - VERIFIED
23. ✅ Task 6.2: Created GroupFormComponent (create/edit) - VERIFIED
24. ✅ Task 6.3: Created GroupUsersComponent (manage members) - VERIFIED
25. ✅ Task 6.4: Updated GroupResponse (added users field + UserSummary DTO) - VERIFIED
26. ✅ Task 6.5: Added group routes to app.routes.ts - VERIFIED
27. ✅ Task 6.6: Updated navigation component (Groups menu with SYSTEM_MANAGE) - VERIFIED
28. ✅ Task 7: Backend GroupMapper updated to populate users field - VERIFIED

**All Tasks Complete!** See IMPLEMENTATION_SUMMARY.md for full details.

---

## Batch 1: Database Schema & Migrations

**Goal:** Create database tables for groups and migrate existing user roles to group-based roles.

### Task 1.1: Create Groups Table Migration

**Files:**
- Create: `backend/src/main/resources/db/migration/V12__create_groups_table.sql`

**Step 1: Create Flyway Migration**

```sql
CREATE TABLE groups (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name VARCHAR(100) NOT NULL UNIQUE,
    description VARCHAR(255),
    created_at TIMESTAMP NOT NULL,
    updated_at TIMESTAMP NOT NULL,
    version BIGINT NOT NULL DEFAULT 0
);

CREATE INDEX idx_groups_name ON groups(name);
```

**Step 2: Verify File Line Endings**

Run (Windows):
```bash
git add backend/src/main/resources/db/migration/V12__create_groups_table.sql
git diff --cached --check
```

Expected: No CRLF warnings (enforced by `.gitattributes`).

---

### Task 1.2: Create User-Groups Join Table Migration

**Files:**
- Create: `backend/src/main/resources/db/migration/V13__create_user_groups_table.sql`

**Step 1: Create Join Table Migration**

```sql
CREATE TABLE user_groups (
    user_id BIGINT NOT NULL,
    group_id BIGINT NOT NULL,
    PRIMARY KEY (user_id, group_id),
    CONSTRAINT fk_user_groups_user FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
    CONSTRAINT fk_user_groups_group FOREIGN KEY (group_id) REFERENCES groups(id) ON DELETE CASCADE
);

CREATE INDEX idx_user_groups_user_id ON user_groups(user_id);
CREATE INDEX idx_user_groups_group_id ON user_groups(group_id);
```

**Step 2: Verify File Line Endings**

Run:
```bash
git add backend/src/main/resources/db/migration/V13__create_user_groups_table.sql
git diff --cached --check
```

Expected: No CRLF warnings.

---

### Task 1.3: Create Group-Roles Join Table Migration

**Files:**
- Create: `backend/src/main/resources/db/migration/V14__create_group_roles_table.sql`

**Step 1: Create Join Table Migration**

```sql
CREATE TABLE group_roles (
    group_id BIGINT NOT NULL,
    role_id BIGINT NOT NULL,
    PRIMARY KEY (group_id, role_id),
    CONSTRAINT fk_group_roles_group FOREIGN KEY (group_id) REFERENCES groups(id) ON DELETE CASCADE,
    CONSTRAINT fk_group_roles_role FOREIGN KEY (role_id) REFERENCES roles(id) ON DELETE CASCADE
);

CREATE INDEX idx_group_roles_group_id ON group_roles(group_id);
CREATE INDEX idx_group_roles_role_id ON group_roles(role_id);
```

**Step 2: Verify File Line Endings**

Run:
```bash
git add backend/src/main/resources/db/migration/V14__create_group_roles_table.sql
git diff --cached --check
```

Expected: No CRLF warnings.

---

### Task 1.4: Create Data Migration Script

**Files:**
- Create: `backend/src/main/resources/db/migration/V15__migrate_user_roles_to_groups.sql`

**Step 1: Create Migration Logic**

```sql
-- Create personal groups for each user
INSERT INTO groups (name, description, created_at, updated_at, version)
SELECT
    CONCAT('personal_', u.username) AS name,
    CONCAT('Personal group for ', u.username) AS description,
    CURRENT_TIMESTAMP AS created_at,
    CURRENT_TIMESTAMP AS updated_at,
    0 AS version
FROM users u
WHERE u.deleted_at IS NULL;

-- Link users to their personal groups
INSERT INTO user_groups (user_id, group_id)
SELECT
    u.id AS user_id,
    g.id AS group_id
FROM users u
INNER JOIN groups g ON g.name = CONCAT('personal_', u.username)
WHERE u.deleted_at IS NULL;

-- Copy user roles to group roles
INSERT INTO group_roles (group_id, role_id)
SELECT DISTINCT
    g.id AS group_id,
    ur.role_id
FROM user_roles ur
INNER JOIN users u ON ur.user_id = u.id
INNER JOIN groups g ON g.name = CONCAT('personal_', u.username)
WHERE u.deleted_at IS NULL;

-- Drop the old user_roles table
DROP TABLE user_roles;
```

**Step 2: Verify File Line Endings**

Run:
```bash
git add backend/src/main/resources/db/migration/V15__migrate_user_roles_to_groups.sql
git diff --cached --check
```

Expected: No CRLF warnings.

---

### Task 1.5: Test Migrations Locally

**Files:**
- None (verification step)

**Step 1: Clean and Rebuild Backend**

Run:
```bash
cd backend
mvn clean compile
```

Expected: Build success, Flyway runs all migrations (V1-V15).

**Step 2: Verify H2 Database Schema**

Access H2 console at `http://localhost:8080/h2-console` (after running `mvn spring-boot:run`):
- JDBC URL: `jdbc:h2:mem:testdb`
- Username: `sa`
- Password: (empty)

Run queries:
```sql
-- Check groups table exists
SELECT COUNT(*) FROM groups;

-- Check personal groups created
SELECT name, description FROM groups WHERE name LIKE 'personal_%';

-- Check user_groups assignments
SELECT u.username, g.name FROM user_groups ug
JOIN users u ON ug.user_id = u.id
JOIN groups g ON ug.group_id = g.id;

-- Verify user_roles table is dropped
SELECT * FROM user_roles;  -- Should fail with table not found
```

Expected: All queries succeed except last one (table dropped).

---

**Batch 1 Review Checkpoint:**
- All 4 migration files created with LF line endings
- Migrations run successfully on H2
- Personal groups created for existing users
- `user_roles` table dropped
- Ready to proceed to backend domain layer

---

## Batch 2: Backend Domain Layer

**Goal:** Create Group entity, update User entity, and add necessary repositories.

### Task 2.1: Create Group Entity

**Files:**
- Create: `backend/src/main/java/com/boilerplate/domain/model/Group.java`

**Step 1: Implement Group Entity**

```java
package com.boilerplate.domain.model;

import jakarta.persistence.*;
import lombok.*;

import java.util.HashSet;
import java.util.Set;

@Entity
@Table(name = "groups")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@lombok.experimental.SuperBuilder
public class Group extends BaseEntity {

    @Column(nullable = false, unique = true, length = 100)
    private String name;

    @Column(length = 255)
    private String description;

    @ManyToMany(fetch = FetchType.LAZY)
    @JoinTable(
        name = "group_roles",
        joinColumns = @JoinColumn(name = "group_id"),
        inverseJoinColumns = @JoinColumn(name = "role_id")
    )
    @Builder.Default
    private Set<Role> roles = new HashSet<>();

    @ManyToMany(mappedBy = "groups", fetch = FetchType.LAZY)
    @Builder.Default
    private Set<User> users = new HashSet<>();
}
```

**Step 2: Verify Compilation**

Run:
```bash
cd backend
mvn clean compile
```

Expected: Compilation success, MapStruct processes entity.

---

### Task 2.2: Update User Entity

**Files:**
- Modify: `backend/src/main/java/com/boilerplate/domain/model/User.java`

**Step 1: Remove Direct Roles and Add Groups**

Find and remove these lines (around line 47-54):
```java
@ManyToMany(fetch = FetchType.EAGER)
@JoinTable(
    name = "user_roles",
    joinColumns = @JoinColumn(name = "user_id"),
    inverseJoinColumns = @JoinColumn(name = "role_id")
)
@Builder.Default
private Set<Role> roles = new HashSet<>();
```

Add this instead:
```java
@ManyToMany(fetch = FetchType.LAZY)
@JoinTable(
    name = "user_groups",
    joinColumns = @JoinColumn(name = "user_id"),
    inverseJoinColumns = @JoinColumn(name = "group_id")
)
@Builder.Default
private Set<Group> groups = new HashSet<>();
```

**Step 2: Verify Compilation**

Run:
```bash
cd backend
mvn clean compile
```

Expected: Compilation success, UserMapper regenerated.

---

### Task 2.3: Create GroupRepository

**Files:**
- Create: `backend/src/main/java/com/boilerplate/domain/repository/GroupRepository.java`

**Step 1: Implement Repository**

```java
package com.boilerplate.domain.repository;

import com.boilerplate.domain.model.Group;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.Optional;

@Repository
public interface GroupRepository extends JpaRepository<Group, Long> {

    @Query("SELECT DISTINCT g FROM Group g LEFT JOIN FETCH g.roles WHERE g.id = :id")
    Optional<Group> findByIdWithRoles(@Param("id") Long id);

    @Query("SELECT DISTINCT g FROM Group g LEFT JOIN FETCH g.roles LEFT JOIN FETCH g.users")
    List<Group> findAllWithRolesAndUsers();

    boolean existsByName(String name);
}
```

**Step 2: Verify Compilation**

Run:
```bash
cd backend
mvn clean compile
```

Expected: Compilation success.

---

### Task 2.4: Update UserRepository

**Files:**
- Modify: `backend/src/main/java/com/boilerplate/domain/repository/UserRepository.java`

**Step 1: Update Existing Query and Add New Query**

Update line 25-26 (change `u.roles` to `u.groups`):
```java
@Query("SELECT u FROM User u LEFT JOIN FETCH u.groups g LEFT JOIN FETCH g.roles r LEFT JOIN FETCH r.permissions WHERE u.username = :username AND u.deletedAt IS NULL")
Optional<User> findByUsernameWithRolesAndPermissions(String username);
```

Add new method after line 26:
```java
@Query("SELECT DISTINCT u FROM User u LEFT JOIN FETCH u.groups g LEFT JOIN FETCH g.roles WHERE u.id = :id AND u.deletedAt IS NULL")
Optional<User> findByIdWithGroupsAndRoles(@Param("id") Long id);
```

Update line 40 (change `u.roles.name` to join through groups):
```java
long countByDeletedAtIsNullAndGroupsRolesName(String roleName);
```

**Step 2: Verify Compilation**

Run:
```bash
cd backend
mvn clean compile
```

Expected: Compilation success.

---

### Task 2.5: Update UserPrincipal to Load Roles from Groups

**Files:**
- Modify: `backend/src/main/java/com/boilerplate/infrastructure/security/UserPrincipal.java`

**Step 1: Change getAuthorities() Method**

Replace lines 23-34 with:
```java
@Override
public Collection<? extends GrantedAuthority> getAuthorities() {
    Set<GrantedAuthority> authorities = new HashSet<>();

    // Flatten roles from all groups
    for (var group : user.getGroups()) {
        for (Role role : group.getRoles()) {
            authorities.add(new SimpleGrantedAuthority("ROLE_" + role.getName()));

            // Add permission-based authorities
            for (Permission permission : role.getPermissions()) {
                authorities.add(new SimpleGrantedAuthority(permission.getName()));
            }
        }
    }

    return authorities;
}
```

Add import at the top (after line 4):
```java
import com.boilerplate.domain.model.Group;
```

**Step 2: Verify Compilation**

Run:
```bash
cd backend
mvn clean compile
```

Expected: Compilation success.

---

**Batch 2 Review Checkpoint:**
- Group entity created with proper JPA mappings
- User entity updated to use groups instead of roles
- Repositories created/updated with JOIN FETCH queries
- UserPrincipal loads roles from groups correctly
- All code compiles successfully
- Ready for application layer (DTOs, Mappers, Services)

---

## Batch 3: Backend Application Layer

**Goal:** Create DTOs, MapStruct mappers, and GroupService with business logic.

### Task 3.1: Create GroupResponse DTO

**Files:**
- Create: `backend/src/main/java/com/boilerplate/application/dto/response/GroupResponse.java`

**Step 1: Implement DTO**

```java
package com.boilerplate.application.dto.response;

import java.time.LocalDateTime;
import java.util.Set;

public record GroupResponse(
    Long id,
    String name,
    String description,
    Set<RoleResponse> roles,
    Integer userCount,
    LocalDateTime createdAt,
    LocalDateTime updatedAt
) {}
```

**Step 2: Verify Compilation**

Run:
```bash
cd backend
mvn clean compile
```

Expected: Compilation success.

---

### Task 3.2: Create GroupRequest DTO

**Files:**
- Create: `backend/src/main/java/com/boilerplate/application/dto/request/GroupRequest.java`

**Step 1: Implement DTO with Validation**

```java
package com.boilerplate.application.dto.request;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;

import java.util.Set;

public record GroupRequest(
    @NotBlank(message = "Name is required")
    @Size(max = 100, message = "Name must not exceed 100 characters")
    String name,

    @Size(max = 255, message = "Description must not exceed 255 characters")
    String description,

    Set<Long> roleIds
) {}
```

**Step 2: Verify Compilation**

Run:
```bash
cd backend
mvn clean compile
```

Expected: Compilation success.

---

### Task 3.3: Create GroupAssignUsersRequest DTO

**Files:**
- Create: `backend/src/main/java/com/boilerplate/application/dto/request/GroupAssignUsersRequest.java`

**Step 1: Implement DTO**

```java
package com.boilerplate.application.dto.request;

import jakarta.validation.constraints.NotEmpty;

import java.util.Set;

public record GroupAssignUsersRequest(
    @NotEmpty(message = "User IDs cannot be empty")
    Set<Long> userIds
) {}
```

**Step 2: Verify Compilation**

Run:
```bash
cd backend
mvn clean compile
```

Expected: Compilation success.

---

### Task 3.4: Create GroupMapper

**Files:**
- Create: `backend/src/main/java/com/boilerplate/application/mapper/GroupMapper.java`

**Step 1: Implement MapStruct Mapper**

```java
package com.boilerplate.application.mapper;

import com.boilerplate.application.dto.request.GroupRequest;
import com.boilerplate.application.dto.response.GroupResponse;
import com.boilerplate.domain.model.Group;
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;

@Mapper(componentModel = "spring", uses = {RoleMapper.class})
public interface GroupMapper {

    @Mapping(target = "userCount", expression = "java(group.getUsers().size())")
    GroupResponse toResponse(Group group);

    @Mapping(target = "id", ignore = true)
    @Mapping(target = "roles", ignore = true)
    @Mapping(target = "users", ignore = true)
    @Mapping(target = "createdAt", ignore = true)
    @Mapping(target = "updatedAt", ignore = true)
    @Mapping(target = "version", ignore = true)
    Group toEntity(GroupRequest request);
}
```

**Step 2: Verify MapStruct Generation**

Run:
```bash
cd backend
mvn clean compile
```

Expected: Compilation success, `GroupMapperImpl.java` generated in `target/generated-sources/annotations`.

---

### Task 3.5: Create GroupHasUsersException

**Files:**
- Create: `backend/src/main/java/com/boilerplate/presentation/exception/GroupHasUsersException.java`

**Step 1: Implement Exception**

```java
package com.boilerplate.presentation.exception;

public class GroupHasUsersException extends RuntimeException {
    public GroupHasUsersException(String message) {
        super(message);
    }
}
```

**Step 2: Update GlobalExceptionHandler**

Modify: `backend/src/main/java/com/boilerplate/presentation/exception/GlobalExceptionHandler.java`

Add this method after the existing exception handlers:
```java
@ExceptionHandler(GroupHasUsersException.class)
public ResponseEntity<ErrorResponse> handleGroupHasUsers(GroupHasUsersException ex) {
    ErrorResponse error = new ErrorResponse(
        HttpStatus.CONFLICT.value(),
        ex.getMessage(),
        LocalDateTime.now()
    );
    return new ResponseEntity<>(error, HttpStatus.CONFLICT);
}
```

**Step 3: Verify Compilation**

Run:
```bash
cd backend
mvn clean compile
```

Expected: Compilation success.

---

### Task 3.6: Create GroupService

**Files:**
- Create: `backend/src/main/java/com/boilerplate/application/service/GroupService.java`

**Step 1: Implement Service**

```java
package com.boilerplate.application.service;

import com.boilerplate.application.dto.request.GroupAssignUsersRequest;
import com.boilerplate.application.dto.request.GroupRequest;
import com.boilerplate.application.dto.response.GroupResponse;
import com.boilerplate.application.mapper.GroupMapper;
import com.boilerplate.domain.model.Group;
import com.boilerplate.domain.model.Role;
import com.boilerplate.domain.model.User;
import com.boilerplate.domain.repository.GroupRepository;
import com.boilerplate.domain.repository.RoleRepository;
import com.boilerplate.domain.repository.UserRepository;
import com.boilerplate.presentation.exception.DuplicateResourceException;
import com.boilerplate.presentation.exception.GroupHasUsersException;
import com.boilerplate.presentation.exception.ResourceNotFoundException;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.HashSet;
import java.util.List;
import java.util.Set;

@Service
@RequiredArgsConstructor
public class GroupService {

    private final GroupRepository groupRepository;
    private final RoleRepository roleRepository;
    private final UserRepository userRepository;
    private final GroupMapper groupMapper;

    @Transactional(readOnly = true)
    public List<GroupResponse> getAllGroups() {
        return groupRepository.findAllWithRolesAndUsers().stream()
            .map(groupMapper::toResponse)
            .toList();
    }

    @Transactional(readOnly = true)
    public GroupResponse getGroupById(Long id) {
        Group group = groupRepository.findByIdWithRoles(id)
            .orElseThrow(() -> new ResourceNotFoundException("Group not found with id: " + id));
        return groupMapper.toResponse(group);
    }

    @Transactional
    public GroupResponse createGroup(GroupRequest request) {
        // Check for duplicate name
        if (groupRepository.existsByName(request.name())) {
            throw new DuplicateResourceException("Group already exists with name: " + request.name());
        }

        Group group = groupMapper.toEntity(request);

        // Assign roles if provided
        if (request.roleIds() != null && !request.roleIds().isEmpty()) {
            Set<Role> roles = new HashSet<>(roleRepository.findAllById(request.roleIds()));
            if (roles.size() != request.roleIds().size()) {
                throw new ResourceNotFoundException("One or more role IDs not found");
            }
            group.setRoles(roles);
        }

        Group savedGroup = groupRepository.save(group);
        return groupMapper.toResponse(savedGroup);
    }

    @Transactional
    public GroupResponse updateGroup(Long id, GroupRequest request) {
        Group group = groupRepository.findByIdWithRoles(id)
            .orElseThrow(() -> new ResourceNotFoundException("Group not found with id: " + id));

        // Check for duplicate name (excluding current group)
        if (!group.getName().equals(request.name()) && groupRepository.existsByName(request.name())) {
            throw new DuplicateResourceException("Group already exists with name: " + request.name());
        }

        group.setName(request.name());
        group.setDescription(request.description());

        // Update roles
        if (request.roleIds() != null) {
            Set<Role> roles = new HashSet<>(roleRepository.findAllById(request.roleIds()));
            if (roles.size() != request.roleIds().size()) {
                throw new ResourceNotFoundException("One or more role IDs not found");
            }
            group.setRoles(roles);
        } else {
            group.getRoles().clear();
        }

        Group updatedGroup = groupRepository.save(group);
        return groupMapper.toResponse(updatedGroup);
    }

    @Transactional
    public void deleteGroup(Long id) {
        Group group = groupRepository.findById(id)
            .orElseThrow(() -> new ResourceNotFoundException("Group not found with id: " + id));

        // Prevent deletion if group has users
        if (!group.getUsers().isEmpty()) {
            throw new GroupHasUsersException(
                "Cannot delete group with existing users. Please remove all users first."
            );
        }

        groupRepository.delete(group);
    }

    @Transactional
    public GroupResponse assignUsersToGroup(Long groupId, GroupAssignUsersRequest request) {
        Group group = groupRepository.findByIdWithRoles(groupId)
            .orElseThrow(() -> new ResourceNotFoundException("Group not found with id: " + groupId));

        List<User> users = userRepository.findAllById(request.userIds());
        if (users.size() != request.userIds().size()) {
            throw new ResourceNotFoundException("One or more user IDs not found");
        }

        // Add users to group
        for (User user : users) {
            user.getGroups().add(group);
            group.getUsers().add(user);
        }

        userRepository.saveAll(users);
        Group updatedGroup = groupRepository.save(group);
        return groupMapper.toResponse(updatedGroup);
    }

    @Transactional
    public void removeUserFromGroup(Long groupId, Long userId) {
        Group group = groupRepository.findById(groupId)
            .orElseThrow(() -> new ResourceNotFoundException("Group not found with id: " + groupId));

        User user = userRepository.findById(userId)
            .orElseThrow(() -> new ResourceNotFoundException("User not found with id: " + userId));

        user.getGroups().remove(group);
        group.getUsers().remove(user);

        userRepository.save(user);
        groupRepository.save(group);
    }
}
```

**Step 2: Verify Compilation**

Run:
```bash
cd backend
mvn clean compile
```

Expected: Compilation success.

---

**Batch 3 Review Checkpoint:**
- All DTOs created (GroupResponse, GroupRequest, GroupAssignUsersRequest)
- GroupMapper generated by MapStruct
- GroupHasUsersException added to exception handling
- GroupService implemented with all CRUD operations and validations
- All code compiles successfully
- Ready for presentation layer (controllers)

---

## Batch 4: Backend Presentation Layer & Testing

**Goal:** Create REST controllers and unit tests.

### Task 4.1: Create GroupController

**Files:**
- Create: `backend/src/main/java/com/boilerplate/presentation/controller/GroupController.java`

**Step 1: Implement REST Controller**

```java
package com.boilerplate.presentation.controller;

import com.boilerplate.application.dto.request.GroupAssignUsersRequest;
import com.boilerplate.application.dto.request.GroupRequest;
import com.boilerplate.application.dto.response.GroupResponse;
import com.boilerplate.application.service.GroupService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.security.SecurityRequirement;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/groups")
@RequiredArgsConstructor
@SecurityRequirement(name = "bearerAuth")
@Tag(name = "Groups", description = "Group management endpoints")
public class GroupController {

    private final GroupService groupService;

    @GetMapping
    @PreAuthorize("hasAuthority('SYSTEM_MANAGE')")
    @Operation(summary = "Get all groups", description = "Retrieve list of all groups with roles and user counts")
    public ResponseEntity<List<GroupResponse>> getAllGroups() {
        List<GroupResponse> groups = groupService.getAllGroups();
        return ResponseEntity.ok(groups);
    }

    @GetMapping("/{id}")
    @PreAuthorize("hasAuthority('SYSTEM_MANAGE')")
    @Operation(summary = "Get group by ID", description = "Retrieve a specific group by its ID")
    public ResponseEntity<GroupResponse> getGroupById(@PathVariable Long id) {
        GroupResponse group = groupService.getGroupById(id);
        return ResponseEntity.ok(group);
    }

    @PostMapping
    @PreAuthorize("hasAuthority('SYSTEM_MANAGE')")
    @Operation(summary = "Create new group", description = "Create a new group with optional role assignments")
    public ResponseEntity<GroupResponse> createGroup(@Valid @RequestBody GroupRequest request) {
        GroupResponse group = groupService.createGroup(request);
        return new ResponseEntity<>(group, HttpStatus.CREATED);
    }

    @PutMapping("/{id}")
    @PreAuthorize("hasAuthority('SYSTEM_MANAGE')")
    @Operation(summary = "Update group", description = "Update an existing group's details and role assignments")
    public ResponseEntity<GroupResponse> updateGroup(
        @PathVariable Long id,
        @Valid @RequestBody GroupRequest request
    ) {
        GroupResponse group = groupService.updateGroup(id, request);
        return ResponseEntity.ok(group);
    }

    @DeleteMapping("/{id}")
    @PreAuthorize("hasAuthority('SYSTEM_MANAGE')")
    @Operation(summary = "Delete group", description = "Delete a group (only if it has no users)")
    public ResponseEntity<Void> deleteGroup(@PathVariable Long id) {
        groupService.deleteGroup(id);
        return ResponseEntity.noContent().build();
    }

    @PostMapping("/{id}/users")
    @PreAuthorize("hasAuthority('SYSTEM_MANAGE')")
    @Operation(summary = "Assign users to group", description = "Add multiple users to a group")
    public ResponseEntity<GroupResponse> assignUsers(
        @PathVariable Long id,
        @Valid @RequestBody GroupAssignUsersRequest request
    ) {
        GroupResponse group = groupService.assignUsersToGroup(id, request);
        return ResponseEntity.ok(group);
    }

    @DeleteMapping("/{groupId}/users/{userId}")
    @PreAuthorize("hasAuthority('SYSTEM_MANAGE')")
    @Operation(summary = "Remove user from group", description = "Remove a specific user from a group")
    public ResponseEntity<Void> removeUser(
        @PathVariable Long groupId,
        @PathVariable Long userId
    ) {
        groupService.removeUserFromGroup(groupId, userId);
        return ResponseEntity.noContent().build();
    }
}
```

**Step 2: Verify Compilation**

Run:
```bash
cd backend
mvn clean compile
```

Expected: Compilation success.

---

### Task 4.2: Update UserResponse DTO

**Files:**
- Modify: `backend/src/main/java/com/boilerplate/application/dto/response/UserResponse.java`

**Step 1: Add Groups Field**

Find the record definition and add `groups` field (keep `roles` for backward compatibility but compute from groups):

```java
// Add this import at top
import java.util.stream.Collectors;

// Modify the record to add groups field
public record UserResponse(
    Long id,
    String username,
    String email,
    Boolean enabled,
    Set<RoleResponse> roles,  // Keep for backward compatibility
    Set<GroupResponse> groups,  // New field
    LocalDateTime createdAt,
    LocalDateTime updatedAt
) {}
```

**Step 2: Update UserMapper**

Modify: `backend/src/main/java/com/boilerplate/application/mapper/UserMapper.java`

Update the `toResponse` mapping:
```java
@Mapping(target = "roles", expression = "java(extractRolesFromGroups(user))")
@Mapping(target = "groups", source = "groups")
UserResponse toResponse(User user);

default Set<RoleResponse> extractRolesFromGroups(User user) {
    return user.getGroups().stream()
        .flatMap(group -> group.getRoles().stream())
        .map(role -> new RoleResponse(
            role.getId(),
            role.getName(),
            role.getDescription(),
            null  // Skip permissions for brevity
        ))
        .collect(Collectors.toSet());
}
```

Add imports:
```java
import java.util.stream.Collectors;
import com.boilerplate.application.dto.response.GroupResponse;
```

**Step 3: Verify Compilation**

Run:
```bash
cd backend
mvn clean compile
```

Expected: Compilation success, UserMapper regenerated.

---

### Task 4.3: Create GroupServiceTest

**Files:**
- Create: `backend/src/test/java/com/boilerplate/application/service/GroupServiceTest.java`

**Step 1: Implement Unit Tests**

```java
package com.boilerplate.application.service;

import com.boilerplate.application.dto.request.GroupAssignUsersRequest;
import com.boilerplate.application.dto.request.GroupRequest;
import com.boilerplate.application.dto.response.GroupResponse;
import com.boilerplate.application.mapper.GroupMapper;
import com.boilerplate.domain.model.Group;
import com.boilerplate.domain.model.Role;
import com.boilerplate.domain.model.User;
import com.boilerplate.domain.repository.GroupRepository;
import com.boilerplate.domain.repository.RoleRepository;
import com.boilerplate.domain.repository.UserRepository;
import com.boilerplate.presentation.exception.DuplicateResourceException;
import com.boilerplate.presentation.exception.GroupHasUsersException;
import com.boilerplate.presentation.exception.ResourceNotFoundException;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;

import java.util.*;

import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatThrownBy;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
class GroupServiceTest {

    @Mock
    private GroupRepository groupRepository;

    @Mock
    private RoleRepository roleRepository;

    @Mock
    private UserRepository userRepository;

    @Mock
    private GroupMapper groupMapper;

    @InjectMocks
    private GroupService groupService;

    @Test
    void testCreateGroup_Success() {
        // Arrange
        GroupRequest request = new GroupRequest("Engineering", "Engineering team", Set.of(1L));
        Group group = Group.builder().name("Engineering").description("Engineering team").build();
        GroupResponse response = new GroupResponse(1L, "Engineering", "Engineering team", Set.of(), 0, null, null);
        Role role = Role.builder().id(1L).name("DEVELOPER").build();

        when(groupRepository.existsByName("Engineering")).thenReturn(false);
        when(groupMapper.toEntity(request)).thenReturn(group);
        when(roleRepository.findAllById(Set.of(1L))).thenReturn(List.of(role));
        when(groupRepository.save(any(Group.class))).thenReturn(group);
        when(groupMapper.toResponse(group)).thenReturn(response);

        // Act
        GroupResponse result = groupService.createGroup(request);

        // Assert
        assertThat(result).isNotNull();
        assertThat(result.name()).isEqualTo("Engineering");
        verify(groupRepository).save(any(Group.class));
    }

    @Test
    void testCreateGroup_DuplicateName_ThrowsException() {
        // Arrange
        GroupRequest request = new GroupRequest("Engineering", "Engineering team", Set.of());
        when(groupRepository.existsByName("Engineering")).thenReturn(true);

        // Act & Assert
        assertThatThrownBy(() -> groupService.createGroup(request))
            .isInstanceOf(DuplicateResourceException.class)
            .hasMessageContaining("Group already exists with name: Engineering");
    }

    @Test
    void testUpdateGroup_Success() {
        // Arrange
        Long groupId = 1L;
        GroupRequest request = new GroupRequest("Updated Name", "Updated description", Set.of(1L));
        Group group = Group.builder().id(groupId).name("Old Name").description("Old desc").roles(new HashSet<>()).build();
        GroupResponse response = new GroupResponse(groupId, "Updated Name", "Updated description", Set.of(), 0, null, null);
        Role role = Role.builder().id(1L).name("DEVELOPER").build();

        when(groupRepository.findByIdWithRoles(groupId)).thenReturn(Optional.of(group));
        when(groupRepository.existsByName("Updated Name")).thenReturn(false);
        when(roleRepository.findAllById(Set.of(1L))).thenReturn(List.of(role));
        when(groupRepository.save(any(Group.class))).thenReturn(group);
        when(groupMapper.toResponse(group)).thenReturn(response);

        // Act
        GroupResponse result = groupService.updateGroup(groupId, request);

        // Assert
        assertThat(result).isNotNull();
        assertThat(result.name()).isEqualTo("Updated Name");
        verify(groupRepository).save(any(Group.class));
    }

    @Test
    void testDeleteGroup_WithUsers_ThrowsException() {
        // Arrange
        Long groupId = 1L;
        User user = User.builder().id(1L).username("testuser").build();
        Group group = Group.builder().id(groupId).name("Engineering").users(new HashSet<>(Set.of(user))).build();

        when(groupRepository.findById(groupId)).thenReturn(Optional.of(group));

        // Act & Assert
        assertThatThrownBy(() -> groupService.deleteGroup(groupId))
            .isInstanceOf(GroupHasUsersException.class)
            .hasMessageContaining("Cannot delete group with existing users");
    }

    @Test
    void testAssignUsers_ValidUserIds_Success() {
        // Arrange
        Long groupId = 1L;
        GroupAssignUsersRequest request = new GroupAssignUsersRequest(Set.of(1L, 2L));
        Group group = Group.builder().id(groupId).name("Engineering").users(new HashSet<>()).roles(new HashSet<>()).build();
        User user1 = User.builder().id(1L).username("user1").groups(new HashSet<>()).build();
        User user2 = User.builder().id(2L).username("user2").groups(new HashSet<>()).build();
        GroupResponse response = new GroupResponse(groupId, "Engineering", "Eng team", Set.of(), 2, null, null);

        when(groupRepository.findByIdWithRoles(groupId)).thenReturn(Optional.of(group));
        when(userRepository.findAllById(Set.of(1L, 2L))).thenReturn(List.of(user1, user2));
        when(userRepository.saveAll(anyList())).thenReturn(List.of(user1, user2));
        when(groupRepository.save(any(Group.class))).thenReturn(group);
        when(groupMapper.toResponse(group)).thenReturn(response);

        // Act
        GroupResponse result = groupService.assignUsersToGroup(groupId, request);

        // Assert
        assertThat(result).isNotNull();
        assertThat(result.userCount()).isEqualTo(2);
        verify(userRepository).saveAll(anyList());
        verify(groupRepository).save(any(Group.class));
    }

    @Test
    void testAssignUsers_InvalidUserId_ThrowsException() {
        // Arrange
        Long groupId = 1L;
        GroupAssignUsersRequest request = new GroupAssignUsersRequest(Set.of(1L, 999L));
        Group group = Group.builder().id(groupId).name("Engineering").build();
        User user1 = User.builder().id(1L).username("user1").build();

        when(groupRepository.findByIdWithRoles(groupId)).thenReturn(Optional.of(group));
        when(userRepository.findAllById(Set.of(1L, 999L))).thenReturn(List.of(user1));

        // Act & Assert
        assertThatThrownBy(() -> groupService.assignUsersToGroup(groupId, request))
            .isInstanceOf(ResourceNotFoundException.class)
            .hasMessageContaining("One or more user IDs not found");
    }

    @Test
    void testGetGroupById_NotFound_ThrowsException() {
        // Arrange
        Long groupId = 999L;
        when(groupRepository.findByIdWithRoles(groupId)).thenReturn(Optional.empty());

        // Act & Assert
        assertThatThrownBy(() -> groupService.getGroupById(groupId))
            .isInstanceOf(ResourceNotFoundException.class)
            .hasMessageContaining("Group not found with id: 999");
    }
}
```

**Step 2: Run Tests**

Run:
```bash
cd backend
mvn test -Dtest=GroupServiceTest
```

Expected: All tests pass.

---

### Task 4.4: Test Backend APIs with Swagger

**Files:**
- None (manual verification)

**Step 1: Start Backend**

Run:
```bash
cd backend
mvn spring-boot:run
```

**Step 2: Access Swagger UI**

Open browser: `http://localhost:8080/swagger-ui.html`

**Step 3: Test Group Endpoints**

1. Login as admin (POST `/api/auth/login`):
   - Username: `admin`
   - Password: `admin123`
   - Copy JWT token

2. Click "Authorize" button, paste token as `Bearer <token>`

3. Test these endpoints:
   - GET `/api/groups` - Should return list including personal groups
   - POST `/api/groups` - Create "Engineering" group with role IDs
   - GET `/api/groups/{id}` - Get group by ID
   - PUT `/api/groups/{id}` - Update group name/description
   - POST `/api/groups/{id}/users` - Assign users to group
   - DELETE `/api/groups/{groupId}/users/{userId}` - Remove user from group
   - DELETE `/api/groups/{id}` - Delete group (should fail if has users)

Expected: All endpoints work, return correct responses, enforce SYSTEM_MANAGE permission.

---

**Batch 4 Review Checkpoint:**
- GroupController created with 7 REST endpoints
- UserResponse updated to include groups
- GroupServiceTest passes all 7 test cases
- Manual testing via Swagger confirms APIs work
- Backend fully functional
- Ready for frontend implementation

---

## Batch 5: Frontend Core (Angular)

**Goal:** Create TypeScript interfaces and GroupService for API integration.

### Task 5.1: Create TypeScript Interfaces

**Files:**
- Create: `frontend/src/app/core/models/group.model.ts`

**Step 1: Define Interfaces**

```typescript
import { RoleResponse } from './role.model';

export interface GroupResponse {
  id: number;
  name: string;
  description: string;
  roles: RoleResponse[];
  userCount: number;
  createdAt: string;
  updatedAt: string;
}

export interface GroupRequest {
  name: string;
  description: string;
  roleIds: number[];
}

export interface GroupAssignUsersRequest {
  userIds: number[];
}
```

**Step 2: Verify TypeScript Compilation**

Run:
```bash
cd frontend
pnpm lint
```

Expected: No errors.

---

### Task 5.2: Create GroupService

**Files:**
- Create: `frontend/src/app/core/services/group.service.ts`

**Step 1: Implement Service**

```typescript
import { Injectable, inject } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { Observable } from 'rxjs';
import { environment } from '../../../environments/environment';
import { GroupResponse, GroupRequest, GroupAssignUsersRequest } from '../models/group.model';

@Injectable({
  providedIn: 'root'
})
export class GroupService {
  private http = inject(HttpClient);
  private apiUrl = `${environment.apiUrl}/groups`;

  getAllGroups(): Observable<GroupResponse[]> {
    return this.http.get<GroupResponse[]>(this.apiUrl);
  }

  getGroupById(id: number): Observable<GroupResponse> {
    return this.http.get<GroupResponse>(`${this.apiUrl}/${id}`);
  }

  createGroup(request: GroupRequest): Observable<GroupResponse> {
    return this.http.post<GroupResponse>(this.apiUrl, request);
  }

  updateGroup(id: number, request: GroupRequest): Observable<GroupResponse> {
    return this.http.put<GroupResponse>(`${this.apiUrl}/${id}`, request);
  }

  deleteGroup(id: number): Observable<void> {
    return this.http.delete<void>(`${this.apiUrl}/${id}`);
  }

  assignUsers(groupId: number, request: GroupAssignUsersRequest): Observable<GroupResponse> {
    return this.http.post<GroupResponse>(`${this.apiUrl}/${groupId}/users`, request);
  }

  removeUser(groupId: number, userId: number): Observable<void> {
    return this.http.delete<void>(`${this.apiUrl}/${groupId}/users/${userId}`);
  }
}
```

**Step 2: Verify TypeScript Compilation**

Run:
```bash
cd frontend
pnpm lint
```

Expected: No errors.

---

### Task 5.3: Update UserResponse Model

**Files:**
- Modify: `frontend/src/app/core/models/user.model.ts`

**Step 1: Add Groups Field**

Find the `UserResponse` interface and add `groups` field:

```typescript
import { RoleResponse } from './role.model';
import { GroupResponse } from './group.model';

export interface UserResponse {
  id: number;
  username: string;
  email: string;
  enabled: boolean;
  roles: RoleResponse[];  // Keep for backward compatibility
  groups: GroupResponse[];  // New field
  createdAt: string;
  updatedAt: string;
}
```

**Step 2: Verify TypeScript Compilation**

Run:
```bash
cd frontend
pnpm lint
```

Expected: No errors.

---

**Batch 5 Review Checkpoint:**
- TypeScript interfaces created (GroupResponse, GroupRequest, GroupAssignUsersRequest)
- GroupService created with all 7 API methods
- UserResponse model updated to include groups
- TypeScript compilation succeeds
- Ready for frontend components

---

## Batch 6: Frontend Components (Angular)

**Goal:** Create UI components for group management.

### Task 6.1: Create GroupListComponent

**Files:**
- Create: `frontend/src/app/features/groups/group-list/group-list.component.ts`
- Create: `frontend/src/app/features/groups/group-list/group-list.component.html`

**Step 1: Generate Component**

Run:
```bash
cd frontend
pnpm exec ng generate component features/groups/group-list --standalone
```

**Step 2: Implement Component Logic**

Edit `group-list.component.ts`:

```typescript
import { Component, OnInit, inject } from '@angular/core';
import { CommonModule } from '@angular/common';
import { Router } from '@angular/router';
import { GroupService } from '../../../core/services/group.service';
import { GroupResponse } from '../../../core/models/group.model';

@Component({
  selector: 'app-group-list',
  standalone: true,
  imports: [CommonModule],
  templateUrl: './group-list.component.html'
})
export class GroupListComponent implements OnInit {
  private groupService = inject(GroupService);
  private router = inject(Router);

  groups: GroupResponse[] = [];
  loading = false;
  error: string | null = null;

  ngOnInit(): void {
    this.loadGroups();
  }

  loadGroups(): void {
    this.loading = true;
    this.error = null;
    this.groupService.getAllGroups().subscribe({
      next: (data) => {
        this.groups = data;
        this.loading = false;
      },
      error: (err) => {
        this.error = 'Failed to load groups';
        this.loading = false;
        console.error(err);
      }
    });
  }

  createGroup(): void {
    this.router.navigate(['/groups/create']);
  }

  editGroup(id: number): void {
    this.router.navigate(['/groups/edit', id]);
  }

  deleteGroup(id: number, name: string): void {
    if (confirm(`Are you sure you want to delete group "${name}"?`)) {
      this.groupService.deleteGroup(id).subscribe({
        next: () => {
          this.loadGroups();
        },
        error: (err) => {
          alert(err.error?.message || 'Failed to delete group');
        }
      });
    }
  }

  manageUsers(id: number): void {
    this.router.navigate(['/groups', id, 'users']);
  }
}
```

**Step 3: Implement Component Template**

Edit `group-list.component.html`:

```html
<div class="container mx-auto px-4 py-8">
  <div class="flex justify-between items-center mb-6">
    <h1 class="text-3xl font-bold">Groups</h1>
    <button
      (click)="createGroup()"
      class="bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded"
    >
      Create Group
    </button>
  </div>

  <div *ngIf="loading" class="text-center py-8">
    <p class="text-gray-600">Loading groups...</p>
  </div>

  <div *ngIf="error" class="bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded mb-4">
    {{ error }}
  </div>

  <div *ngIf="!loading && !error" class="bg-white shadow-md rounded">
    <table class="min-w-full">
      <thead class="bg-gray-100">
        <tr>
          <th class="px-6 py-3 text-left text-xs font-medium text-gray-700 uppercase">Name</th>
          <th class="px-6 py-3 text-left text-xs font-medium text-gray-700 uppercase">Description</th>
          <th class="px-6 py-3 text-left text-xs font-medium text-gray-700 uppercase">Roles</th>
          <th class="px-6 py-3 text-left text-xs font-medium text-gray-700 uppercase">Users</th>
          <th class="px-6 py-3 text-left text-xs font-medium text-gray-700 uppercase">Actions</th>
        </tr>
      </thead>
      <tbody class="divide-y divide-gray-200">
        <tr *ngFor="let group of groups" class="hover:bg-gray-50">
          <td class="px-6 py-4 whitespace-nowrap font-medium">{{ group.name }}</td>
          <td class="px-6 py-4">{{ group.description || '-' }}</td>
          <td class="px-6 py-4 whitespace-nowrap">{{ group.roles.length }}</td>
          <td class="px-6 py-4 whitespace-nowrap">{{ group.userCount }}</td>
          <td class="px-6 py-4 whitespace-nowrap space-x-2">
            <button
              (click)="editGroup(group.id)"
              class="text-blue-600 hover:text-blue-800"
            >
              Edit
            </button>
            <button
              (click)="manageUsers(group.id)"
              class="text-green-600 hover:text-green-800"
            >
              Users
            </button>
            <button
              (click)="deleteGroup(group.id, group.name)"
              class="text-red-600 hover:text-red-800"
              [disabled]="group.userCount > 0"
              [class.opacity-50]="group.userCount > 0"
            >
              Delete
            </button>
          </td>
        </tr>
      </tbody>
    </table>

    <div *ngIf="groups.length === 0" class="text-center py-8 text-gray-500">
      No groups found. Create your first group to get started.
    </div>
  </div>
</div>
```

**Step 4: Verify Compilation**

Run:
```bash
cd frontend
pnpm lint
```

Expected: No errors.

---

### Task 6.2: Create GroupFormComponent

**Files:**
- Create: `frontend/src/app/features/groups/group-form/group-form.component.ts`
- Create: `frontend/src/app/features/groups/group-form/group-form.component.html`

**Step 1: Generate Component**

Run:
```bash
cd frontend
pnpm exec ng generate component features/groups/group-form --standalone
```

**Step 2: Implement Component Logic**

Edit `group-form.component.ts`:

```typescript
import { Component, OnInit, inject } from '@angular/core';
import { CommonModule } from '@angular/common';
import { FormBuilder, FormGroup, Validators, ReactiveFormsModule } from '@angular/forms';
import { ActivatedRoute, Router } from '@angular/router';
import { GroupService } from '../../../core/services/group.service';
import { RoleService } from '../../../core/services/role.service';
import { GroupRequest } from '../../../core/models/group.model';
import { RoleResponse } from '../../../core/models/role.model';

@Component({
  selector: 'app-group-form',
  standalone: true,
  imports: [CommonModule, ReactiveFormsModule],
  templateUrl: './group-form.component.html'
})
export class GroupFormComponent implements OnInit {
  private fb = inject(FormBuilder);
  private groupService = inject(GroupService);
  private roleService = inject(RoleService);
  private route = inject(ActivatedRoute);
  private router = inject(Router);

  groupForm: FormGroup;
  roles: RoleResponse[] = [];
  isEditMode = false;
  groupId: number | null = null;
  loading = false;
  error: string | null = null;

  constructor() {
    this.groupForm = this.fb.group({
      name: ['', [Validators.required, Validators.maxLength(100)]],
      description: ['', Validators.maxLength(255)],
      roleIds: [[]]
    });
  }

  ngOnInit(): void {
    this.loadRoles();

    this.route.params.subscribe(params => {
      if (params['id']) {
        this.isEditMode = true;
        this.groupId = +params['id'];
        this.loadGroup(this.groupId);
      }
    });
  }

  loadRoles(): void {
    this.roleService.getAllRoles().subscribe({
      next: (data) => {
        this.roles = data;
      },
      error: (err) => {
        console.error('Failed to load roles', err);
      }
    });
  }

  loadGroup(id: number): void {
    this.groupService.getGroupById(id).subscribe({
      next: (group) => {
        this.groupForm.patchValue({
          name: group.name,
          description: group.description,
          roleIds: group.roles.map(r => r.id)
        });
      },
      error: (err) => {
        this.error = 'Failed to load group';
        console.error(err);
      }
    });
  }

  toggleRole(roleId: number): void {
    const roleIds = this.groupForm.get('roleIds')?.value || [];
    const index = roleIds.indexOf(roleId);

    if (index > -1) {
      roleIds.splice(index, 1);
    } else {
      roleIds.push(roleId);
    }

    this.groupForm.patchValue({ roleIds });
  }

  isRoleSelected(roleId: number): boolean {
    const roleIds = this.groupForm.get('roleIds')?.value || [];
    return roleIds.includes(roleId);
  }

  onSubmit(): void {
    if (this.groupForm.invalid) {
      return;
    }

    this.loading = true;
    this.error = null;

    const request: GroupRequest = this.groupForm.value;

    const operation = this.isEditMode && this.groupId
      ? this.groupService.updateGroup(this.groupId, request)
      : this.groupService.createGroup(request);

    operation.subscribe({
      next: () => {
        this.router.navigate(['/groups']);
      },
      error: (err) => {
        this.error = err.error?.message || 'Failed to save group';
        this.loading = false;
      }
    });
  }

  cancel(): void {
    this.router.navigate(['/groups']);
  }
}
```

**Step 3: Implement Component Template**

Edit `group-form.component.html`:

```html
<div class="container mx-auto px-4 py-8 max-w-2xl">
  <h1 class="text-3xl font-bold mb-6">{{ isEditMode ? 'Edit Group' : 'Create Group' }}</h1>

  <div *ngIf="error" class="bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded mb-4">
    {{ error }}
  </div>

  <form [formGroup]="groupForm" (ngSubmit)="onSubmit()" class="bg-white shadow-md rounded px-8 py-6">
    <div class="mb-4">
      <label class="block text-gray-700 text-sm font-bold mb-2" for="name">
        Name <span class="text-red-500">*</span>
      </label>
      <input
        id="name"
        type="text"
        formControlName="name"
        class="shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline"
        [class.border-red-500]="groupForm.get('name')?.invalid && groupForm.get('name')?.touched"
      />
      <p *ngIf="groupForm.get('name')?.invalid && groupForm.get('name')?.touched" class="text-red-500 text-xs italic mt-1">
        Name is required and must not exceed 100 characters.
      </p>
    </div>

    <div class="mb-4">
      <label class="block text-gray-700 text-sm font-bold mb-2" for="description">
        Description
      </label>
      <textarea
        id="description"
        formControlName="description"
        rows="3"
        class="shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline"
        [class.border-red-500]="groupForm.get('description')?.invalid && groupForm.get('description')?.touched"
      ></textarea>
      <p *ngIf="groupForm.get('description')?.invalid && groupForm.get('description')?.touched" class="text-red-500 text-xs italic mt-1">
        Description must not exceed 255 characters.
      </p>
    </div>

    <div class="mb-6">
      <label class="block text-gray-700 text-sm font-bold mb-2">
        Roles
      </label>
      <div class="space-y-2">
        <div *ngFor="let role of roles" class="flex items-center">
          <input
            type="checkbox"
            [id]="'role-' + role.id"
            [checked]="isRoleSelected(role.id)"
            (change)="toggleRole(role.id)"
            class="mr-2"
          />
          <label [for]="'role-' + role.id" class="text-gray-700 cursor-pointer">
            {{ role.name }} <span class="text-gray-500 text-sm">{{ role.description }}</span>
          </label>
        </div>
      </div>
    </div>

    <div class="flex items-center justify-end space-x-4">
      <button
        type="button"
        (click)="cancel()"
        class="bg-gray-500 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded focus:outline-none"
      >
        Cancel
      </button>
      <button
        type="submit"
        [disabled]="groupForm.invalid || loading"
        class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded focus:outline-none disabled:opacity-50"
      >
        {{ loading ? 'Saving...' : (isEditMode ? 'Update' : 'Create') }}
      </button>
    </div>
  </form>
</div>
```

**Step 4: Verify Compilation**

Run:
```bash
cd frontend
pnpm lint
```

Expected: No errors.

---

### Task 6.3: Create GroupUsersComponent

**Files:**
- Create: `frontend/src/app/features/groups/group-users/group-users.component.ts`
- Create: `frontend/src/app/features/groups/group-users/group-users.component.html`

**Step 1: Generate Component**

Run:
```bash
cd frontend
pnpm exec ng generate component features/groups/group-users --standalone
```

**Step 2: Implement Component Logic**

Edit `group-users.component.ts`:

```typescript
import { Component, OnInit, inject } from '@angular/core';
import { CommonModule } from '@angular/common';
import { ActivatedRoute, Router } from '@angular/router';
import { GroupService } from '../../../core/services/group.service';
import { UserService } from '../../../core/services/user.service';
import { GroupResponse } from '../../../core/models/group.model';
import { UserResponse } from '../../../core/models/user.model';

@Component({
  selector: 'app-group-users',
  standalone: true,
  imports: [CommonModule],
  templateUrl: './group-users.component.html'
})
export class GroupUsersComponent implements OnInit {
  private groupService = inject(GroupService);
  private userService = inject(UserService);
  private route = inject(ActivatedRoute);
  private router = inject(Router);

  group: GroupResponse | null = null;
  allUsers: UserResponse[] = [];
  availableUsers: UserResponse[] = [];
  groupId: number | null = null;
  loading = false;
  error: string | null = null;
  showAddUsersModal = false;
  selectedUserIds: number[] = [];

  ngOnInit(): void {
    this.route.params.subscribe(params => {
      this.groupId = +params['id'];
      this.loadGroup();
      this.loadAllUsers();
    });
  }

  loadGroup(): void {
    if (!this.groupId) return;

    this.loading = true;
    this.groupService.getGroupById(this.groupId).subscribe({
      next: (data) => {
        this.group = data;
        this.loading = false;
        this.updateAvailableUsers();
      },
      error: (err) => {
        this.error = 'Failed to load group';
        this.loading = false;
        console.error(err);
      }
    });
  }

  loadAllUsers(): void {
    this.userService.getUsers(0, 1000).subscribe({
      next: (response) => {
        this.allUsers = response.content;
        this.updateAvailableUsers();
      },
      error: (err) => {
        console.error('Failed to load users', err);
      }
    });
  }

  updateAvailableUsers(): void {
    if (!this.group) return;

    const groupUserIds = this.group.users?.map(u => u.id) || [];
    this.availableUsers = this.allUsers.filter(user => !groupUserIds.includes(user.id));
  }

  openAddUsersModal(): void {
    this.selectedUserIds = [];
    this.showAddUsersModal = true;
  }

  closeAddUsersModal(): void {
    this.showAddUsersModal = false;
    this.selectedUserIds = [];
  }

  toggleUserSelection(userId: number): void {
    const index = this.selectedUserIds.indexOf(userId);
    if (index > -1) {
      this.selectedUserIds.splice(index, 1);
    } else {
      this.selectedUserIds.push(userId);
    }
  }

  isUserSelected(userId: number): boolean {
    return this.selectedUserIds.includes(userId);
  }

  addUsers(): void {
    if (!this.groupId || this.selectedUserIds.length === 0) return;

    this.loading = true;
    this.groupService.assignUsers(this.groupId, { userIds: this.selectedUserIds }).subscribe({
      next: () => {
        this.closeAddUsersModal();
        this.loadGroup();
        this.loading = false;
      },
      error: (err) => {
        this.error = err.error?.message || 'Failed to add users';
        this.loading = false;
      }
    });
  }

  removeUser(userId: number, username: string): void {
    if (!this.groupId) return;

    if (confirm(`Remove user "${username}" from this group?`)) {
      this.groupService.removeUser(this.groupId, userId).subscribe({
        next: () => {
          this.loadGroup();
        },
        error: (err) => {
          alert(err.error?.message || 'Failed to remove user');
        }
      });
    }
  }

  goBack(): void {
    this.router.navigate(['/groups']);
  }
}
```

**Step 3: Implement Component Template**

Edit `group-users.component.html`:

```html
<div class="container mx-auto px-4 py-8">
  <div class="flex items-center mb-6">
    <button (click)="goBack()" class="mr-4 text-blue-600 hover:text-blue-800">
      ← Back to Groups
    </button>
    <h1 class="text-3xl font-bold" *ngIf="group">{{ group.name }} - Users</h1>
  </div>

  <div *ngIf="loading" class="text-center py-8">
    <p class="text-gray-600">Loading...</p>
  </div>

  <div *ngIf="error" class="bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded mb-4">
    {{ error }}
  </div>

  <div *ngIf="!loading && group" class="bg-white shadow-md rounded">
    <div class="p-4 border-b flex justify-between items-center">
      <h2 class="text-xl font-semibold">Group Members ({{ group.userCount }})</h2>
      <button
        (click)="openAddUsersModal()"
        class="bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded"
      >
        Add Users
      </button>
    </div>

    <table class="min-w-full" *ngIf="group.users && group.users.length > 0">
      <thead class="bg-gray-100">
        <tr>
          <th class="px-6 py-3 text-left text-xs font-medium text-gray-700 uppercase">Username</th>
          <th class="px-6 py-3 text-left text-xs font-medium text-gray-700 uppercase">Email</th>
          <th class="px-6 py-3 text-left text-xs font-medium text-gray-700 uppercase">Actions</th>
        </tr>
      </thead>
      <tbody class="divide-y divide-gray-200">
        <tr *ngFor="let user of group.users" class="hover:bg-gray-50">
          <td class="px-6 py-4 whitespace-nowrap">{{ user.username }}</td>
          <td class="px-6 py-4 whitespace-nowrap">{{ user.email }}</td>
          <td class="px-6 py-4 whitespace-nowrap">
            <button
              (click)="removeUser(user.id, user.username)"
              class="text-red-600 hover:text-red-800"
            >
              Remove
            </button>
          </td>
        </tr>
      </tbody>
    </table>

    <div *ngIf="!group.users || group.users.length === 0" class="text-center py-8 text-gray-500">
      No users in this group. Add users to get started.
    </div>
  </div>

  <!-- Add Users Modal -->
  <div *ngIf="showAddUsersModal" class="fixed inset-0 bg-gray-600 bg-opacity-50 overflow-y-auto h-full w-full z-50">
    <div class="relative top-20 mx-auto p-5 border w-11/12 md:w-3/4 lg:w-1/2 shadow-lg rounded-md bg-white">
      <div class="flex justify-between items-center mb-4">
        <h3 class="text-xl font-bold">Add Users to Group</h3>
        <button (click)="closeAddUsersModal()" class="text-gray-600 hover:text-gray-900">✕</button>
      </div>

      <div class="max-h-96 overflow-y-auto">
        <div *ngFor="let user of availableUsers" class="flex items-center py-2 border-b">
          <input
            type="checkbox"
            [id]="'user-' + user.id"
            [checked]="isUserSelected(user.id)"
            (change)="toggleUserSelection(user.id)"
            class="mr-3"
          />
          <label [for]="'user-' + user.id" class="cursor-pointer flex-1">
            <span class="font-medium">{{ user.username }}</span>
            <span class="text-gray-500 text-sm ml-2">{{ user.email }}</span>
          </label>
        </div>

        <div *ngIf="availableUsers.length === 0" class="text-center py-8 text-gray-500">
          All users are already in this group.
        </div>
      </div>

      <div class="flex justify-end space-x-4 mt-4">
        <button
          (click)="closeAddUsersModal()"
          class="bg-gray-500 hover:bg-gray-700 text-white px-4 py-2 rounded"
        >
          Cancel
        </button>
        <button
          (click)="addUsers()"
          [disabled]="selectedUserIds.length === 0"
          class="bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded disabled:opacity-50"
        >
          Add Selected ({{ selectedUserIds.length }})
        </button>
      </div>
    </div>
  </div>
</div>
```

**Step 4: Update GroupResponse Model to Include Users**

Modify: `frontend/src/app/core/models/group.model.ts`

```typescript
import { RoleResponse } from './role.model';
import { UserResponse } from './user.model';

export interface GroupResponse {
  id: number;
  name: string;
  description: string;
  roles: RoleResponse[];
  users?: UserResponse[];  // Optional, only populated in detail view
  userCount: number;
  createdAt: string;
  updatedAt: string;
}
```

**Step 5: Verify Compilation**

Run:
```bash
cd frontend
pnpm lint
```

Expected: No errors.

---

### Task 6.4: Add Group Routes

**Files:**
- Modify: `frontend/src/app/app.routes.ts`

**Step 1: Add Group Routes**

Find the routes array and add these routes:

```typescript
import { GroupListComponent } from './features/groups/group-list/group-list.component';
import { GroupFormComponent } from './features/groups/group-form/group-form.component';
import { GroupUsersComponent } from './features/groups/group-users/group-users.component';

// Add to routes array
{
  path: 'groups',
  canActivate: [authGuard],
  children: [
    {
      path: '',
      component: GroupListComponent
    },
    {
      path: 'create',
      component: GroupFormComponent
    },
    {
      path: 'edit/:id',
      component: GroupFormComponent
    },
    {
      path: ':id/users',
      component: GroupUsersComponent
    }
  ]
},
```

**Step 2: Verify Compilation**

Run:
```bash
cd frontend
pnpm lint
```

Expected: No errors.

---

### Task 6.5: Update Navigation Component

**Files:**
- Modify: `frontend/src/app/core/layout/navbar/navbar.component.ts` (or equivalent)
- Modify: `frontend/src/app/core/layout/navbar/navbar.component.html`

**Step 1: Add Permission Check Method**

Edit navigation component TypeScript:

```typescript
import { AuthService } from '../../services/auth.service';

// In component class
private authService = inject(AuthService);

hasSystemManage(): boolean {
  const user = this.authService.currentUser();
  if (!user) return false;

  // Check if user has SYSTEM_MANAGE permission through any group
  return user.groups?.some(group =>
    group.roles?.some(role =>
      role.permissions?.some(p => p.name === 'SYSTEM_MANAGE')
    )
  ) || false;
}
```

**Step 2: Add Groups Menu Item**

Edit navigation component HTML:

```html
<!-- Add after Users menu item -->
<a
  *ngIf="hasSystemManage()"
  routerLink="/groups"
  routerLinkActive="bg-gray-900"
  class="px-3 py-2 rounded-md text-sm font-medium hover:bg-gray-700"
>
  Groups
</a>
```

**Step 3: Verify Compilation**

Run:
```bash
cd frontend
pnpm lint
```

Expected: No errors.

---

**Batch 6 Review Checkpoint:**
- GroupListComponent created with table view and actions
- GroupFormComponent created for create/edit with role selection
- GroupUsersComponent created with add/remove users functionality
- Routes configured for all group pages
- Navigation updated to show Groups menu (SYSTEM_MANAGE only)
- All TypeScript compiles successfully
- Ready for end-to-end testing

---

## Batch 7: End-to-End Testing & Verification

**Goal:** Test the complete feature from database to UI.

### Task 7.1: Test Backend Migrations

**Files:**
- None (verification step)

**Step 1: Clean Database and Restart**

Run:
```bash
cd backend
mvn clean
mvn spring-boot:run
```

**Step 2: Verify H2 Console**

Access `http://localhost:8080/h2-console`

Run queries:
```sql
-- Check personal groups were created
SELECT id, name, description FROM groups WHERE name LIKE 'personal_%';

-- Check admin user has personal group
SELECT u.username, g.name FROM user_groups ug
JOIN users u ON ug.user_id = u.id
JOIN groups g ON ug.group_id = g.id
WHERE u.username = 'admin';

-- Check admin's roles transferred to group
SELECT g.name AS group_name, r.name AS role_name FROM group_roles gr
JOIN groups g ON gr.group_id = g.id
JOIN roles r ON gr.role_id = r.id
WHERE g.name = 'personal_admin';

-- Verify user_roles table dropped
SELECT * FROM user_roles;  -- Should error
```

Expected: Personal groups exist, admin in personal_admin group, admin's roles transferred, user_roles table gone.

---

### Task 7.2: Test Backend APIs via Swagger

**Files:**
- None (manual testing)

**Step 1: Login and Get Token**

1. Open `http://localhost:8080/swagger-ui.html`
2. POST `/api/auth/login`
   - Body: `{"username": "admin", "password": "admin123"}`
   - Copy JWT token from response

**Step 2: Authorize Swagger**

Click "Authorize" button, enter: `Bearer <your_token>`

**Step 3: Test Group CRUD**

1. GET `/api/groups` - Verify personal_admin group appears
2. POST `/api/groups`:
   ```json
   {
     "name": "Engineering",
     "description": "Engineering team",
     "roleIds": [1]
   }
   ```
   - Should return 201 Created

3. GET `/api/groups/{id}` - Fetch Engineering group
4. PUT `/api/groups/{id}` - Update description
5. DELETE `/api/groups/{id}` - Should fail if users assigned (test with personal_admin)

**Step 4: Test User Assignment**

1. POST `/api/groups/{engineeringId}/users`:
   ```json
   {
     "userIds": [1]
   }
   ```
2. DELETE `/api/groups/{engineeringId}/users/1` - Remove user

**Step 5: Test Permission Enforcement**

1. Create new user without SYSTEM_MANAGE
2. Login as that user
3. Try GET `/api/groups` - Should return 403 Forbidden

Expected: All CRUD operations work, permissions enforced.

---

### Task 7.3: Test Frontend Application

**Files:**
- None (manual testing)

**Step 1: Start Frontend**

Run:
```bash
cd frontend
pnpm dev
```

**Step 2: Login as Admin**

1. Navigate to `http://localhost:4200`
2. Login with admin/admin123
3. Verify "Groups" menu item appears in navigation

**Step 3: Test Group List**

1. Click "Groups" menu
2. Verify personal_admin group appears in table
3. Verify correct role count and user count

**Step 4: Test Group Creation**

1. Click "Create Group" button
2. Fill form:
   - Name: "Engineering"
   - Description: "Engineering Department"
   - Select roles (e.g., USER, MODERATOR)
3. Click "Create"
4. Verify redirect to list and Engineering group appears

**Step 5: Test Group Edit**

1. Click "Edit" on Engineering group
2. Change description to "Software Engineering"
3. Add/remove roles
4. Click "Update"
5. Verify changes saved

**Step 6: Test User Assignment**

1. Click "Users" button on Engineering group
2. Click "Add Users" button
3. Select admin user from modal
4. Click "Add Selected"
5. Verify admin appears in group users table
6. Click "Remove" to remove admin
7. Confirm removal

**Step 7: Test Delete Protection**

1. Go back to groups list
2. Try to delete Engineering group (with users)
3. Verify delete button disabled
4. Remove all users first
5. Delete group successfully

**Step 8: Test Non-Admin User**

1. Create new user via `/api/users` (Swagger)
2. Logout
3. Login as new user
4. Verify "Groups" menu NOT visible
5. Try accessing `/groups` directly
6. Verify redirect to dashboard or 403 error

Expected: All UI flows work, permission checks enforce SYSTEM_MANAGE.

---

### Task 7.4: Run Automated Tests

**Files:**
- None (verification step)

**Step 1: Run Backend Tests**

Run:
```bash
cd backend
mvn test
```

Expected: All tests pass, including new GroupServiceTest.

**Step 2: Run Backend Code Quality Checks**

Run:
```bash
cd backend
mvn verify
```

Expected: Checkstyle, SpotBugs, JaCoCo all pass.

**Step 3: Run Frontend Linting**

Run:
```bash
cd frontend
pnpm lint
```

Expected: No errors or warnings.

**Step 4: Build Production Frontend**

Run:
```bash
cd frontend
pnpm build
```

Expected: Build succeeds, no errors.

---

### Task 7.5: Test Edge Cases

**Files:**
- None (manual testing)

**Test Cases:**

1. **User with no groups:**
   - Remove admin from personal_admin group via H2 console
   - Login as admin
   - Verify limited access (no permissions)
   - Re-assign to group

2. **Group with no roles:**
   - Create group without selecting roles
   - Assign user to group
   - Login as that user
   - Verify user has no permissions

3. **Duplicate group name:**
   - Try creating group with existing name
   - Verify 409 Conflict error with message

4. **Non-existent role/user IDs:**
   - POST `/api/groups` with roleIds: [9999]
   - Verify 404 Not Found error

5. **Multi-group user:**
   - Assign admin to Engineering and personal_admin
   - Login as admin
   - Verify permissions aggregated from both groups

Expected: All edge cases handled gracefully with proper error messages.

---

**Batch 7 Review Checkpoint:**
- Database migrations verified
- Backend APIs tested via Swagger
- Frontend UI flows tested manually
- Automated tests pass
- Code quality checks pass
- Edge cases handled correctly
- Feature complete and production-ready

---

## Final Deliverables

**Completed Implementation:**

1. **Database Layer:**
   - 4 new Flyway migrations (V12-V15)
   - Personal groups migrated from user_roles
   - user_roles table dropped

2. **Backend (Spring Boot):**
   - Group entity with JPA mappings
   - User entity updated (groups instead of roles)
   - GroupRepository with optimized queries
   - GroupService with full CRUD + validations
   - GroupController with 7 REST endpoints
   - UserPrincipal loads roles from groups
   - Exception handling (GroupHasUsersException)
   - Unit tests (GroupServiceTest)

3. **Frontend (Angular):**
   - TypeScript models (GroupResponse, GroupRequest)
   - GroupService for API integration
   - GroupListComponent (table view)
   - GroupFormComponent (create/edit)
   - GroupUsersComponent (manage members)
   - Routes configured
   - Navigation updated (SYSTEM_MANAGE check)

4. **Documentation:**
   - Design document
   - Implementation plan (this file)
   - OpenAPI/Swagger documentation

**Success Criteria Met:**
- ✅ Groups organize users by department/team
- ✅ Users get roles only through group membership
- ✅ Zero access loss during migration (personal groups)
- ✅ Flat group structure (no hierarchy)
- ✅ Users can belong to multiple groups
- ✅ SYSTEM_MANAGE permission enforced
- ✅ All tests pass
- ✅ Code quality verified

**Next Steps (Optional):**
- Create real department groups (Engineering, Sales, etc.)
- Migrate users from personal groups to department groups
- Delete empty personal groups
- Consider adding audit logging for group changes
- Add bulk user assignment feature

---

## Commit Strategy

Recommended git commits by batch:

```bash
# Batch 1
git add backend/src/main/resources/db/migration/V12__create_groups_table.sql
git add backend/src/main/resources/db/migration/V13__create_user_groups_table.sql
git add backend/src/main/resources/db/migration/V14__create_group_roles_table.sql
git add backend/src/main/resources/db/migration/V15__migrate_user_roles_to_groups.sql
git commit -m "feat(groups): add database schema and migration for group-based roles"

# Batch 2
git add backend/src/main/java/com/boilerplate/domain/model/Group.java
git add backend/src/main/java/com/boilerplate/domain/model/User.java
git add backend/src/main/java/com/boilerplate/domain/repository/GroupRepository.java
git add backend/src/main/java/com/boilerplate/domain/repository/UserRepository.java
git add backend/src/main/java/com/boilerplate/infrastructure/security/UserPrincipal.java
git commit -m "feat(groups): add Group entity and update User to support group-based roles"

# Batch 3
git add backend/src/main/java/com/boilerplate/application/dto/
git add backend/src/main/java/com/boilerplate/application/mapper/GroupMapper.java
git add backend/src/main/java/com/boilerplate/application/service/GroupService.java
git add backend/src/main/java/com/boilerplate/presentation/exception/GroupHasUsersException.java
git add backend/src/main/java/com/boilerplate/presentation/exception/GlobalExceptionHandler.java
git commit -m "feat(groups): implement GroupService with CRUD operations and validation"

# Batch 4
git add backend/src/main/java/com/boilerplate/presentation/controller/GroupController.java
git add backend/src/test/java/com/boilerplate/application/service/GroupServiceTest.java
git commit -m "feat(groups): add REST controller and unit tests for group management"

# Batch 5
git add frontend/src/app/core/models/group.model.ts
git add frontend/src/app/core/services/group.service.ts
git add frontend/src/app/core/models/user.model.ts
git commit -m "feat(groups): add TypeScript models and API service for groups"

# Batch 6
git add frontend/src/app/features/groups/
git add frontend/src/app/app.routes.ts
git add frontend/src/app/core/layout/navbar/
git commit -m "feat(groups): implement group management UI components

- Add GroupListComponent for viewing all groups
- Add GroupFormComponent for create/edit operations
- Add GroupUsersComponent for managing group membership
- Update navigation to show Groups menu for SYSTEM_MANAGE users

Co-Authored-By: Claude Sonnet 4.5 <noreply@anthropic.com>"

# Final
git add docs/plans/2026-01-31-user-group-management/
git commit -m "docs(groups): add design and implementation plan

Co-Authored-By: Claude Sonnet 4.5 <noreply@anthropic.com>"
```
