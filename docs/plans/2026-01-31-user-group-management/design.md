# User Group Management Feature - Design Document

**Date:** 2026-01-31
**Status:** Validated
**Approach:** Clean Migration with Personal Groups

## Overview

Add user group management to organize users by departments/teams and control access through group-based role assignment. Users will only get roles through group membership (no direct user-to-role assignment).

## Requirements Summary

- **Purpose:** Organizational structure (departments/teams) + Access control (group-based roles)
- **Group Model:** Flat structure, no hierarchy
- **User Membership:** Users can belong to multiple groups
- **Role Assignment:** Groups only - remove direct user-to-role assignment
- **Migration:** Auto-create personal groups for existing users to preserve access
- **Permissions:** SYSTEM_MANAGE only (most restrictive)
- **Frontend:** Angular 18 implementation

---

## Database Schema & Migrations

### New Tables

**V12__create_groups_table.sql:**
```sql
CREATE TABLE groups (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name VARCHAR(100) NOT NULL UNIQUE,
    description VARCHAR(255),
    created_at TIMESTAMP NOT NULL,
    updated_at TIMESTAMP NOT NULL,
    version BIGINT NOT NULL DEFAULT 0
);
CREATE INDEX idx_groups_name ON groups(name);
```

**V13__create_user_groups_table.sql:**
```sql
CREATE TABLE user_groups (
    user_id BIGINT NOT NULL,
    group_id BIGINT NOT NULL,
    PRIMARY KEY (user_id, group_id),
    CONSTRAINT fk_user_groups_user FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
    CONSTRAINT fk_user_groups_group FOREIGN KEY (group_id) REFERENCES groups(id) ON DELETE CASCADE
);
CREATE INDEX idx_user_groups_user_id ON user_groups(user_id);
CREATE INDEX idx_user_groups_group_id ON user_groups(group_id);
```

**V14__create_group_roles_table.sql:**
```sql
CREATE TABLE group_roles (
    group_id BIGINT NOT NULL,
    role_id BIGINT NOT NULL,
    PRIMARY KEY (group_id, role_id),
    CONSTRAINT fk_group_roles_group FOREIGN KEY (group_id) REFERENCES groups(id) ON DELETE CASCADE,
    CONSTRAINT fk_group_roles_role FOREIGN KEY (role_id) REFERENCES roles(id) ON DELETE CASCADE
);
CREATE INDEX idx_group_roles_group_id ON group_roles(group_id);
CREATE INDEX idx_group_roles_role_id ON group_roles(role_id);
```

### Migration Strategy

**V15__migrate_user_roles_to_groups.sql:**
1. For each user, create a personal group named `personal_<username>`
2. Copy user's roles from `user_roles` to `group_roles` for their personal group
3. Link user to their personal group in `user_groups`
4. Drop `user_roles` table

This ensures zero access loss during migration.

---

## Backend Domain Layer

### Group Entity

**Location:** `backend/src/main/java/com/boilerplate/domain/model/Group.java`

```java
@Entity
@Table(name = "groups")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
public class Group extends BaseEntity {

    @Column(nullable = false, unique = true, length = 100)
    private String name;

    @Column(length = 255)
    private String description;

    @ManyToMany(fetch = FetchType.LAZY)
    @JoinTable(
        name = "group_roles",
        joinColumns = @JoinColumn(name = "group_id"),
        inverseJoinColumns = @JoinColumn(name = "role_id")
    )
    @Builder.Default
    private Set<Role> roles = new HashSet<>();

    @ManyToMany(mappedBy = "groups", fetch = FetchType.LAZY)
    @Builder.Default
    private Set<User> users = new HashSet<>();
}
```

### Updated User Entity

**Location:** `backend/src/main/java/com/boilerplate/domain/model/User.java`

**Changes:**
- Remove `roles` field and `@ManyToMany` annotation
- Add new `groups` field:

```java
@ManyToMany(fetch = FetchType.LAZY)
@JoinTable(
    name = "user_groups",
    joinColumns = @JoinColumn(name = "user_id"),
    inverseJoinColumns = @JoinColumn(name = "group_id")
)
@Builder.Default
private Set<Group> groups = new HashSet<>();
```

### Repositories

**GroupRepository.java:**
```java
public interface GroupRepository extends JpaRepository<Group, Long> {

    @Query("SELECT DISTINCT g FROM Group g LEFT JOIN FETCH g.roles WHERE g.id = :id")
    Optional<Group> findByIdWithRoles(@Param("id") Long id);

    @Query("SELECT DISTINCT g FROM Group g LEFT JOIN FETCH g.roles LEFT JOIN FETCH g.users")
    List<Group> findAllWithRolesAndUsers();

    boolean existsByName(String name);
}
```

**Updated UserRepository.java:**
```java
@Query("SELECT DISTINCT u FROM User u LEFT JOIN FETCH u.groups g LEFT JOIN FETCH g.roles WHERE u.id = :id")
Optional<User> findByIdWithGroupsAndRoles(@Param("id") Long id);
```

---

## Application Layer

### DTOs

**GroupResponse.java:**
```java
public record GroupResponse(
    Long id,
    String name,
    String description,
    Set<RoleResponse> roles,
    Integer userCount,
    LocalDateTime createdAt,
    LocalDateTime updatedAt
) {}
```

**GroupRequest.java:**
```java
public record GroupRequest(
    @NotBlank(message = "Name is required")
    @Size(max = 100, message = "Name must not exceed 100 characters")
    String name,

    @Size(max = 255, message = "Description must not exceed 255 characters")
    String description,

    Set<Long> roleIds
) {}
```

**GroupAssignUsersRequest.java:**
```java
public record GroupAssignUsersRequest(
    @NotEmpty(message = "User IDs cannot be empty")
    Set<Long> userIds
) {}
```

### MapStruct Mapper

**GroupMapper.java:**
```java
@Mapper(componentModel = "spring", uses = {RoleMapper.class})
public interface GroupMapper {

    @Mapping(target = "userCount", expression = "java(group.getUsers().size())")
    GroupResponse toResponse(Group group);

    @Mapping(target = "id", ignore = true)
    @Mapping(target = "roles", ignore = true)
    @Mapping(target = "users", ignore = true)
    @Mapping(target = "createdAt", ignore = true)
    @Mapping(target = "updatedAt", ignore = true)
    @Mapping(target = "version", ignore = true)
    Group toEntity(GroupRequest request);
}
```

### GroupService

**Location:** `backend/src/main/java/com/boilerplate/application/service/GroupService.java`

**Methods:**
- `List<GroupResponse> getAllGroups()`
- `GroupResponse getGroupById(Long id)`
- `GroupResponse createGroup(GroupRequest request)`
- `GroupResponse updateGroup(Long id, GroupRequest request)`
- `void deleteGroup(Long id)`
- `GroupResponse assignUsersToGroup(Long groupId, GroupAssignUsersRequest request)`
- `GroupResponse removeUserFromGroup(Long groupId, Long userId)`

**Validations:**
- Group name uniqueness (throw `DuplicateResourceException`)
- Role IDs exist before assignment (throw `ResourceNotFoundException`)
- User IDs exist before group assignment (throw `ResourceNotFoundException`)
- Prevent deleting groups that have users (throw custom exception or require manual user removal first)

### Updated UserDetailsService

**Changes:**
- Load roles from `user.getGroups()` instead of `user.getRoles()`
- Flatten all roles from all groups the user belongs to

---

## Presentation Layer

### GroupController

**Location:** `backend/src/main/java/com/boilerplate/presentation/controller/GroupController.java`

**Endpoints:**

| Method | Path | Permission | Description |
|--------|------|------------|-------------|
| GET | `/api/groups` | SYSTEM_MANAGE | Get all groups |
| GET | `/api/groups/{id}` | SYSTEM_MANAGE | Get group by ID |
| POST | `/api/groups` | SYSTEM_MANAGE | Create new group |
| PUT | `/api/groups/{id}` | SYSTEM_MANAGE | Update group |
| DELETE | `/api/groups/{id}` | SYSTEM_MANAGE | Delete group |
| POST | `/api/groups/{id}/users` | SYSTEM_MANAGE | Assign users to group |
| DELETE | `/api/groups/{groupId}/users/{userId}` | SYSTEM_MANAGE | Remove user from group |

All endpoints protected with `@PreAuthorize("hasAuthority('SYSTEM_MANAGE')")` and OpenAPI annotations.

### Updated UserResponse

**Changes:**
- Replace `Set<RoleResponse> roles` with `Set<GroupResponse> groups`
- Or add `Set<RoleResponse> effectiveRoles` computed from all groups

### Exception Handling

- Reuse `DuplicateResourceException` for duplicate group names
- Reuse `ResourceNotFoundException` for group/user not found
- Add `GroupHasUsersException` if trying to delete a group with members

---

## Frontend Layer (Angular)

### GroupService

**Location:** `frontend/src/app/core/services/group.service.ts`

```typescript
@Injectable({ providedIn: 'root' })
export class GroupService {
  private apiUrl = `${environment.apiUrl}/groups`;

  constructor(private http: HttpClient) {}

  getAllGroups(): Observable<GroupResponse[]>;
  getGroupById(id: number): Observable<GroupResponse>;
  createGroup(request: GroupRequest): Observable<GroupResponse>;
  updateGroup(id: number, request: GroupRequest): Observable<GroupResponse>;
  deleteGroup(id: number): Observable<void>;
  assignUsers(groupId: number, userIds: number[]): Observable<GroupResponse>;
  removeUser(groupId: number, userId: number): Observable<void>;
}
```

### TypeScript Interfaces

**Location:** `frontend/src/app/core/models/`

```typescript
interface GroupResponse {
  id: number;
  name: string;
  description: string;
  roles: RoleResponse[];
  userCount: number;
  createdAt: string;
  updatedAt: string;
}

interface GroupRequest {
  name: string;
  description: string;
  roleIds: number[];
}
```

### Components

**1. GroupListComponent**
- Location: `frontend/src/app/features/groups/group-list/`
- Purpose: Main table view with TanStack Query
- Features:
  - Display: group name, description, role count, user count, actions
  - Actions: Edit, Delete, View Users buttons
  - "Create Group" button at top
  - Tailwind table with hover states
  - Pagination (if needed later)

**2. GroupFormComponent**
- Location: `frontend/src/app/features/groups/group-form/`
- Purpose: Create/Edit modal or page
- Features:
  - Reactive form with validators (name required, max lengths)
  - Role multi-select dropdown (checkboxes)
  - Description textarea
  - Submit/Cancel buttons
  - Error handling from API

**3. GroupUsersComponent**
- Location: `frontend/src/app/features/groups/group-users/`
- Purpose: Manage group membership
- Features:
  - Show current users in group (table)
  - "Add Users" button opens multi-select modal
  - Remove user action per row
  - Uses TanStack Query for user list

### Routing

**Add to app.routes.ts:**
```typescript
{
  path: 'groups',
  loadComponent: () => import('./features/groups/group-list/group-list.component'),
  canActivate: [authGuard]
}
```

**Permission Check:**
- Check for `SYSTEM_MANAGE` permission in component `ngOnInit`
- Redirect to dashboard if missing

### Navigation

**Update navigation component:**
- Add "Groups" menu item
- Visible only when `currentUser()` has `SYSTEM_MANAGE` permission

---

## Testing & Validation

### Backend Unit Tests

**GroupServiceTest.java:**
- `testCreateGroup_Success()`
- `testCreateGroup_DuplicateName_ThrowsException()`
- `testUpdateGroup_Success()`
- `testDeleteGroup_WithUsers_ThrowsException()`
- `testAssignUsers_ValidUserIds_Success()`
- `testAssignUsers_InvalidUserId_ThrowsException()`
- `testGetGroupById_NotFound_ThrowsException()`

**UserDetailsServiceTest.java (Update):**
- `testLoadUserByUsername_LoadsRolesFromGroups()`
- `testLoadUserByUsername_MultipleGroups_AggregatesRoles()`

### Migration Testing

- Test V15 migration script on a copy of production data
- Verify each user has exactly one personal group after migration
- Verify role counts match before/after migration
- Verify `user_roles` table is dropped successfully

### Validation Rules

**Backend (JSR-303):**
- Group name: required, unique, max 100 chars
- Description: optional, max 255 chars
- Role IDs: must exist in database
- User IDs: must exist and be enabled (non-deleted)

**Frontend (Reactive Forms):**
- Form validators match backend
- Show error messages from API clearly
- Confirm dialog before deleting group
- Disable delete button if group has users

### Edge Cases

1. **User with no groups** - Should load with empty roles set, login works but limited access
2. **Group with no roles** - Valid, users in group get no permissions
3. **Deleting a role** - Cascade removes from `group_roles` (ON DELETE CASCADE)
4. **Deleting a user** - Cascade removes from `user_groups` (ON DELETE CASCADE)
5. **Deleting a group with users** - **Prevent deletion, require manual user reassignment first**

### Performance Considerations

- Use JOIN FETCH in repositories to prevent N+1 queries
- User login loads groups+roles in single query via `findByIdWithGroupsAndRoles`
- Group list pagination if grows large (start with simple `findAll()`, add later if needed)

---

## Implementation Checklist

### Phase 1: Database & Migrations
- [ ] Create V12__create_groups_table.sql
- [ ] Create V13__create_user_groups_table.sql
- [ ] Create V14__create_group_roles_table.sql
- [ ] Create V15__migrate_user_roles_to_groups.sql
- [ ] Test migrations on local H2 database

### Phase 2: Backend Domain
- [ ] Create Group entity
- [ ] Update User entity (remove roles, add groups)
- [ ] Create GroupRepository
- [ ] Update UserRepository (add findByIdWithGroupsAndRoles)

### Phase 3: Backend Application
- [ ] Create GroupRequest DTO
- [ ] Create GroupResponse DTO
- [ ] Create GroupAssignUsersRequest DTO
- [ ] Create GroupMapper
- [ ] Create GroupService
- [ ] Update UserDetailsService to load roles from groups
- [ ] Create GroupHasUsersException

### Phase 4: Backend Presentation
- [ ] Create GroupController
- [ ] Update UserResponse (add groups or effectiveRoles)
- [ ] Add OpenAPI annotations
- [ ] Write GroupServiceTest
- [ ] Update UserDetailsServiceTest

### Phase 5: Frontend Core
- [ ] Create TypeScript interfaces (GroupResponse, GroupRequest)
- [ ] Create GroupService
- [ ] Update user models if needed

### Phase 6: Frontend Components
- [ ] Create GroupListComponent
- [ ] Create GroupFormComponent
- [ ] Create GroupUsersComponent
- [ ] Add groups route to app.routes.ts
- [ ] Update navigation component (add Groups menu item)

### Phase 7: Testing & Validation
- [ ] Test migration on production-like dataset
- [ ] Test user login with group-based roles
- [ ] Test all CRUD operations
- [ ] Test permission restrictions (SYSTEM_MANAGE only)
- [ ] Test edge cases (empty groups, multi-group users)

---

## Future Enhancements (Out of Scope)

- Group hierarchy (parent/child groups)
- Group-specific permissions (beyond role assignment)
- Audit logging for group changes
- Bulk operations (bulk assign users, bulk delete groups)
- Group templates for quick department setup
- Export/import group configurations

---

## Notes

- **YAGNI Principle:** This design follows the simplest approach that meets requirements. Avoid adding features not explicitly needed.
- **Migration Safety:** Personal groups ensure zero downtime and zero access loss during rollout.
- **Cleanup Recommendation:** After migration, admins should gradually create real department groups and migrate users out of personal groups, then delete empty personal groups.
- **Line Endings:** Ensure all `.sql` migration files use LF line endings (per CLAUDE.md rules) to prevent Flyway checksum errors on Windows.
